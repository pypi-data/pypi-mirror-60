# coding: utf-8

"""
    Fiddle Options Platform

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import unittest
import math
from datetime import date, timedelta

from mercury.client.model.condor import Condor
from mercury.client.model.iron_condor import IronCondor
from mercury.client.model.butterfly import Butterfly
from mercury.client.model import OptionSingle, VerticalSpread, Straddle, Strangle
from mercury.client.model.condor import CondorValueException
from mercury.client.model.option_contract_type import OptionContractType
from mercury.client.model.option_leg import OptionLeg
from mercury.client.model.position import Position
from mercury.client.api.tradeservice_api import TradeserviceApi
from mercury.client.api.marketdata_api import MarketdataApi
from tests.utils import TestUtils, create_api_client


class TestTradeserviceApi(unittest.TestCase):
    """TradeserviceApi unit test stubs"""

    def setUp(self):
        self.api = TradeserviceApi(api_client=create_api_client())
        self.market_api = MarketdataApi(api_client=create_api_client())
        self.test_utils = TestUtils()
        self.equity = 'SPX'
        self.open_date = date(2018, 5, 14)
        self.close_date = date(2018, 5, 18)
        self.exp_date = date(2018, 6, 15)

        self._call_chain = self._get_call_chain()
        self._put_chain = self._get_put_chain()

    def check_caching(self, cache_index, expected_cache_size=1):
        if self.api.is_cached():
            cache_size = self.api.caches[cache_index].currsize
            assert cache_size == expected_cache_size, \
                "Incorrect cache size {}, expected {} ".format(cache_size, expected_cache_size)

    def _get_call_chain(self):
        call_args = dict(contract_type=OptionContractType.CALL,
                         from_strike=0.2,
                         to_strike=0.6,
                         date=self.open_date,
                         expiration_date=self.exp_date)
        return self.market_api.get_vertically_sliced_option_chain_by_delta(self.equity, **call_args)

    def _get_put_chain(self):
        put_args = dict(contract_type=OptionContractType.PUT,
                        from_strike=-0.5,
                        to_strike=0.3,
                        date=self.open_date,
                        expiration_date=self.exp_date)
        return self.market_api.get_vertically_sliced_option_chain_by_delta(self.equity, **put_args)

    def tearDown(self):
        pass

    def _create_complex_position_v1(self):
        position = Position()
        position.add_trade(self._create_iron_condor()).add_trade(self._create_single_option())
        return position

    def _create_complex_position_v2(self):
        trades = list()
        trades.append(self._create_iron_condor())
        trades.append(self._create_single_option(2780))
        position = Position(trades=trades)
        return position

    def _create_iron_condor_position(self):
        ic = self._create_iron_condor()
        return Position(trades=[ic])

    def _create_iron_condor(self):
        put_contracts = self._put_chain.contracts
        call_contracts = self._call_chain.contracts

        put_contracts.sort(key=lambda n: n.strike, reverse=True)
        call_contracts.sort(key=lambda n: n.strike, reverse=False)

        return IronCondor(self.equity, self.open_date, 10,
                          out_leg_call=OptionLeg(contract=call_contracts[0], quantity=1),
                          in_leg_call=OptionLeg(contract=call_contracts[1], quantity=-1),
                          in_leg_put=OptionLeg(contract=put_contracts[0], quantity=-1),
                          out_leg_put=OptionLeg(contract=put_contracts[1], quantity=1))

    def _create_butterfly_position(self, lower_long=2600, mid_short=2650, upper_long=2690):
        """
        :return:
        """
        put_contracts = self._put_chain.contracts
        lower_long_put = [c for c in put_contracts if c.strike == lower_long][0]
        mid_short_put = [c for c in put_contracts if c.strike == mid_short][0]
        upper_long_put = [c for c in put_contracts if c.strike == upper_long][0]
        first_leg = OptionLeg(contract=lower_long_put, quantity=1)
        mid_leg = OptionLeg(contract=mid_short_put, quantity=-2)
        third_leg = OptionLeg(contract=upper_long_put, quantity=1)
        butterfly = Butterfly(symbol=self.equity,
                              quantity=1,
                              opening_date=self.open_date,
                              first_leg=first_leg,
                              mid_leg=mid_leg,
                              third_leg=third_leg)
        return Position(trades=[butterfly])

    def _create_condor_position(self):
        # sort contracts by strike, ascending
        contracts = self._put_chain.contracts
        contracts.sort(key=lambda n: n.strike)

        oll = OptionLeg(contract=contracts[0], quantity=1)
        ilml = OptionLeg(contract=contracts[1], quantity=-1)
        iuml = OptionLeg(contract=contracts[2], quantity=-1)
        oul = OptionLeg(contract=contracts[3], quantity=1)

        condor = Condor(symbol=self.equity,
                        opening_date=self.open_date,
                        quantity=1,
                        out_lower_leg=oll,
                        in_lower_mid_leg=ilml,
                        in_upper_mid_leg=iuml,
                        out_upper_leg=oul)
        return Position(trades=[condor])

    def _create_single_option(self, strike=2780, long=True, call=True):
        if call:
            contracts = self._call_chain.contracts
        else:
            contracts = self._put_chain.contracts

        contract = [c for c in contracts if c.strike == strike][0]
        return OptionSingle(symbol=self.equity,
                            quantity=1 if long else -1,
                            opening_date=self.open_date,
                            option_contract=contract)

    def _create_single_option_position(self, strike=2780, call=True, long=True):
        option_single = self._create_single_option(strike, call=call, long=long)
        return Position(trades=[option_single])

    def _create_vertical_spread_option(self):
        contracts = self._call_chain.contracts
        short_leg = OptionLeg(contract=contracts[1], quantity=-1)
        long_leg = OptionLeg(contract=contracts[0], quantity=1)
        return VerticalSpread(symbol=self.equity,
                              quantity=1,
                              opening_date=self.open_date,
                              short_leg=short_leg,
                              long_leg=long_leg)

    def _create_straddle_position(self):
        return Position(trades=[self._create_straddle()])

    def _create_straddle(self):
        call_contracts = self._call_chain.contracts
        put_contracts = self._put_chain.contracts
        call_strike = filter(lambda x: x.strike == 2715, call_contracts)
        put_strike = filter(lambda x: x.strike == 2715, put_contracts)
        call_leg = OptionLeg(contract=call_strike.__next__(), quantity=1)
        put_leg = OptionLeg(contract=put_strike.__next__(), quantity=1)
        return Straddle(symbol=self.equity,
                        quantity=1,
                        opening_date=self.open_date,
                        call_leg=call_leg,
                        put_leg=put_leg)

    def _create_strangle_position(self):
        return Position(trades=[self._create_strangle()])

    def _create_strangle(self):
        call_contracts = self._call_chain.contracts
        put_contracts = self._put_chain.contracts
        call_leg = OptionLeg(contract=call_contracts[0], quantity=1)
        put_leg = OptionLeg(contract=put_contracts[0], quantity=1)
        return Strangle(symbol=self.equity,
                        quantity=1,
                        opening_date=self.open_date,
                        call_leg=call_leg,
                        put_leg=put_leg)

    def _create_vertical_spread_position(self):
        return Position(trades=[self._create_vertical_spread_option()])

    def _generate_test_positions(self):
        return [self._create_straddle_position(),
                self._create_strangle_position(),
                self._create_iron_condor_position(),
                self._create_vertical_spread_position(),
                self._create_single_option_position(),
                self._create_condor_position(),
                self._create_butterfly_position()]

    def test_create_iron_condor_position(self):
        self._create_iron_condor_position()

    def test_calculate_decomposed_pn_l(self):
        """Test case for calculate_decomposed_pn_l

        Returns the P&L timeline decomposed by greeks for the given trade and the specified time range  # noqa: E501
        """

        for position in self._generate_test_positions():
            data = {'position': position,
                    'from_date': self.open_date,
                    'to_date': self.close_date}
            response = self.api.calculate_decomposed_pn_l(**data)

        # test complex positions
        position = self._create_complex_position_v1()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}
        response = self.api.calculate_decomposed_pn_l(**data)

        position = self._create_complex_position_v2()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}
        response = self.api.calculate_decomposed_pn_l(**data)
        self.check_caching(0, 8)

    def test_calculate_historical_pn_l(self):
        """Test case for calculate_historical_pn_l

        Returns the P&L timeline for the given trade and the specified time range  # noqa: E501
        """
        for position in self._generate_test_positions():
            data = {'position': position,
                    'from_date': self.open_date,
                    'to_date': self.close_date}
            response = self.api.calculate_historical_pn_l(**data)

        position = self._create_complex_position_v1()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}
        response = self.api.calculate_historical_pn_l(**data)

        position = self._create_complex_position_v2()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}
        response = self.api.calculate_historical_pn_l(**data)
        self.check_caching(1, 8)

    def test_calculate_historical_value(self):
        """Test case for calculate_historical_value

        Returns the historical dollar denominated value for the given trade and the time window  # noqa: E501
        """

        for position in self._generate_test_positions():
            data = {'position': position,
                    'from_date': self.open_date,
                    'to_date': self.close_date}
            response = self.api.calculate_historical_value(**data)

        position = self._create_complex_position_v1()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}

        response = self.api.calculate_historical_value(**data)

        position = self._create_complex_position_v2()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}

        response = self.api.calculate_historical_value(**data)

        self.check_caching(2, 8)

    def test_calculate_instant_decomposed_pn_l(self):
        """Test case for calculate_instant_decomposed_pn_l

        Returns the greek decomposed P&L for the given trade and the time window  # noqa: E501
        """
        for position in self._generate_test_positions():
            data = {'position': position,
                    'from_date': self.open_date,
                    'to_date': self.close_date}
            response = self.api.calculate_instant_decomposed_pn_l(**data)
            print(response)

        position = self._create_complex_position_v1()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}
        response = self.api.calculate_instant_decomposed_pn_l(**data)

        position = self._create_complex_position_v2()
        data = {'position': position,
                'from_date': self.open_date,
                'to_date': self.close_date}
        response = self.api.calculate_instant_decomposed_pn_l(**data)

        self.check_caching(3, 8)

        # TODO: add assertion to response

    def test_calculate_pn_l(self):
        """Test case for calculate_pn_l

        Returns the the t+0 curve and expiration PnL curve for the given trade  # noqa: E501
        """
        for position in self._generate_test_positions():
            data = {'position': position,
                    'date': self.open_date + timedelta(days=1)}
            response = self.api.calculate_pn_l(**data)
            print(response)

        position = self._create_complex_position_v1()
        data = {'position': position,
                'date': self.open_date + timedelta(days=1)}
        response = self.api.calculate_pn_l(**data)

        position = self._create_complex_position_v2()
        data = {'position': position,
                'date': self.open_date + timedelta(days=1)}
        response = self.api.calculate_pn_l(**data)
        # todo: check the response

    def test_calculate_pn_l_curve(self):
        """Test case for calculate_pn_l curve

        """
        for position in self._generate_test_positions():
            data = {'position': position,
                    'explicit_stddevs': [-1, 1],
                    'date': self.open_date + timedelta(days=1)}
            response = self.api.calculate_pn_l_curve(**data)

        position = self._create_complex_position_v1()
        data = {'position': position,
                'explicit_stddevs': [-1, 1],
                'date': self.open_date + timedelta(days=1)}
        response = self.api.calculate_pn_l_curve(**data)

        position = self._create_complex_position_v2()
        data = {'position': position,
                'spot_only': True,
                'date': self.open_date + timedelta(days=1)}
        response = self.api.calculate_pn_l_curve(**data)
        assert response.curves[0].pnl_curve[0].profit < 0
        # todo: check the response

    def test_calculate_margin(self):
        """Test case for calculate_pn_l curve

        """

        # calls long
        single = self._create_single_option_position(2780)
        data = {'position': single,
                'date': self.open_date + timedelta(days=1)}
        margin = self.api.calculate_margin(**data)
        assert int(margin) == -1110

        # calls short
        single = self._create_single_option_position(2780, long=False)
        data = {'position': single,
                'date': self.open_date + timedelta(days=1)}
        margin = self.api.calculate_margin(**data)
        assert math.isinf(margin)

        # puts long
        single = self._create_single_option_position(2000, call=False)
        data = {'position': single,
                'date': self.open_date + timedelta(days=1)}
        margin = self.api.calculate_margin(**data)
        assert int(margin) == -45

        # puts short
        single = self._create_single_option_position(2200, call=False, long=False)
        data = {'position': single,
                'date': self.open_date + timedelta(days=1)}
        margin = self.api.calculate_margin(**data)
        assert math.isinf(margin)

        position = self._create_butterfly_position()
        data = {'position': position,
                'date': self.open_date + timedelta(days=1)}
        margin = self.api.calculate_margin(**data)
        assert int(margin) == -1255

        position = self._create_complex_position_v2()
        data = {'position': position,
                'type': 'PortfolioMargin',
                'date': self.open_date + timedelta(days=1)}
        margin = self.api.calculate_margin(**data)
        assert int(margin) == -7210

        self.check_caching(5, 6)

    def test_iron_condor_strike_exception(self):
        with self.assertRaises(CondorValueException) as ctx:
            ic = IronCondor(self.equity, self.open_date, 10,
                            out_leg_call=OptionLeg(strike=1, quantity=1, expiration_date=date(2018, 5, 14),
                                                   opening_price=0.1),
                            in_leg_call=OptionLeg(strike=2, quantity=-1, expiration_date=date(2018, 5, 14),
                                                  opening_price=0.1),
                            in_leg_put=OptionLeg(strike=2, quantity=-1, expiration_date=date(2018, 5, 14),
                                                 opening_price=0.1),
                            out_leg_put=OptionLeg(strike=1, quantity=1, expiration_date=date(2018, 5, 14),
                                                  opening_price=0.1))


if __name__ == '__main__':
    unittest.main()
