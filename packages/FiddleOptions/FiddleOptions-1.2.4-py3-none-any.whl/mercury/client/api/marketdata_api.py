# coding: utf-8

"""
    Fiddle Options Platform

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

# python 2 and python 3 compatibility library
import six

from datetime import date
from threading import RLock
from cachetools import cachedmethod, LRUCache
from cachetools.keys import hashkey

from mercury.api_client import ApiClient


def skew_hashkey(*args, **kwargs):
    key = hashkey(kwargs["symbol"], kwargs["return_pandas"])
    key += tuple(kwargs["expirations"])
    key += tuple(kwargs["date"])
    return key


class MarketdataApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None, cache_size=250):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.cache_size = cache_size
        self.caches = [LRUCache(maxsize=cache_size) for _ in range(12)]
        self.cache_locks = [RLock() for _ in range(12)]

    def is_cached(self):
        return self.cache_size > 0

    @cachedmethod(lambda self: self.caches[0], lock=lambda self: self.cache_locks[0])
    def get_equity_quote(self, name, **kwargs):  # noqa: E501
        """Returns equity quotes for each trading day for the given ticker and time period  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_equity_quote(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date from_date:
        :param date to:
        :return: list[EquityQuote]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_equity_quote_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_equity_quote_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_equity_quote_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns equity quotes for each trading day for the given ticker and time period  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_equity_quote_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date from_date:
        :param date to:
        :return: list[EquityQuote]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'from_date', 'to_date']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_equity_quote" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_equity_quote`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'from_date' in params:
            query_params.append(('from', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('to', params['to_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/equity/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None if params.get('return_pandas') else 'list[EquityQuote]',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[1], lock=lambda self: self.cache_locks[1])
    def get_equity_quote_before(self, name, **kwargs):  # noqa: E501
        """Returns equity quotes for each trading day for the given ticker before the given date and for a given number of trading days  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_equity_quote_before(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date from_date:
        :param int count:
        :return: list[EquityQuote]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_equity_quote_before_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_equity_quote_before_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_equity_quote_before_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns equity quotes for each trading day for the given ticker before the given date and for a given number of trading days  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_equity_quote_before_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date from_date:
        :param int count:
        :return: list[EquityQuote]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'from_date', 'count']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_equity_quote_before" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError(
                "Missing the required parameter `name` when calling `get_equity_quote_before`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'from_date' in params:
            query_params.append(('from', params['from_date']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/equity_before/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None if params.get('return_pandas') else 'list[EquityQuote]',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[2], lock=lambda self: self.cache_locks[2])
    def get_closest_strike_to_delta(self, name, **kwargs):  # noqa: E501
        """Returns option contract from the option chain closest to the given symbol, option type, trading date, expiration, and the delta  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_closest_strike_to_delta(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param str contract_type:
        :param datetime date:
        :param datetime expiration:
        :param float delta:
        :return: OptionContract
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_closest_strike_to_delta_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_closest_strike_to_delta_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_closest_strike_to_delta_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns option contract from the option chain closest to the given symbol, option type, trading date, expiration, and the delta  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_closest_strike_to_delta_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param str contract_type:
        :param datetime date:
        :param datetime expiration:
        :param float delta:
        :return: OptionContract
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'contract_type', 'date', 'expiration', 'delta']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_closest_strike_to_delta" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError(
                "Missing the required parameter `name` when calling `get_closest_strike_to_delta`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'contract_type' in params:
            query_params.append(('contract_type', params['contract_type']))  # noqa: E501
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501
        if 'expiration' in params:
            query_params.append(('expiration', params['expiration']))  # noqa: E501
        if 'delta' in params:
            query_params.append(('delta', params['delta']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/option-chain/{name}/closest-strike-to-delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OptionContract',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[3], lock=lambda self: self.cache_locks[3])
    def get_expirations(self, name, **kwargs):  # noqa: E501
        """Returns expirations for the given symbol and trading date  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_expirations(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date date:
        :return: list[date]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_expirations_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_expirations_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_expirations_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns expirations for the given symbol and trading date  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_expirations_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date date:
        :return: list[date]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'date']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_expirations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_expirations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/option-chain/expirations/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[date]',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[4], lock=lambda self: self.cache_locks[4])
    def get_horizontally_sliced_option_chain_by_delta(self, name, **kwargs):  # noqa: E501
        """Returns horizontal slice of option chain for the given symbol, option type, trading dates, expiration, and the delta strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_horizontally_sliced_option_chain_by_delta(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date from_date:
        :param date to_date:
        :param date expiration:
        :return: list[OptionChain]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_horizontally_sliced_option_chain_by_delta_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_horizontally_sliced_option_chain_by_delta_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_horizontally_sliced_option_chain_by_delta_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns horizontal slice of option chain for the given symbol, option type, trading dates, expiration, and the delta strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_horizontally_sliced_option_chain_by_delta_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date from_date:
        :param date to_date:
        :param date expiration:
        :return: list[OptionChain]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'contract_type', 'from_strike', 'to_strike', 'from_date', 'to_date', 'expiration_date']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_horizontally_sliced_option_chain_by_delta" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_horizontally_sliced_option_chain_by_delta`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'contract_type' in params:
            query_params.append(('contract_type', params['contract_type']))  # noqa: E501
        if 'from_strike' in params:
            query_params.append(('from_strike', params['from_strike']))  # noqa: E501
        if 'to_strike' in params:
            query_params.append(('to_strike', params['to_strike']))  # noqa: E501
        if 'from_date' in params:
            query_params.append(('from_date', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('to_date', params['to_date']))  # noqa: E501
        if 'expiration_date' in params:
            query_params.append(('expiration', params['expiration_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/option-chain/{name}/horizontal-slice-by-delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='contracts' if params.get('return_pandas') else 'list[OptionChain]',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[5], lock=lambda self: self.cache_locks[5])
    def get_horizontally_sliced_option_chain_by_strike(self, name, **kwargs):  # noqa: E501
        """Returns horizontal slice of option chain for the given symbol, option type, trading dates, expiration, and the strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_horizontally_sliced_option_chain_by_strike(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date from_date:
        :param date to_date:
        :param date expiration:
        :return: list[OptionChain]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_horizontally_sliced_option_chain_by_strike_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_horizontally_sliced_option_chain_by_strike_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_horizontally_sliced_option_chain_by_strike_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns horizontal slice of option chain for the given symbol, option type, trading dates, expiration, and the strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_horizontally_sliced_option_chain_by_strike_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date from_date:
        :param date to_date:
        :param date expiration:
        :return: list[OptionChain]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'contract_type', 'from_strike', 'to_strike', 'from_date', 'to_date', 'expiration_date']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_horizontally_sliced_option_chain_by_strike" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_horizontally_sliced_option_chain_by_strike`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'contract_type' in params:
            query_params.append(('contract_type', params['contract_type']))  # noqa: E501
        if 'from_strike' in params:
            query_params.append(('from_strike', params['from_strike']))  # noqa: E501
        if 'to_strike' in params:
            query_params.append(('to_strike', params['to_strike']))  # noqa: E501
        if 'from_date' in params:
            query_params.append(('from_date', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('to_date', params['to_date']))  # noqa: E501
        if 'expiration_date' in params:
            query_params.append(('expiration', params['expiration_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/option-chain/{name}/horizontal-slice-by-strike', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='contracts' if params.get('return_pandas') else 'list[OptionChain]',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[6], lock=lambda self: self.cache_locks[6])
    def get_option_chain(self, name, **kwargs):  # noqa: E501
        """Returns option chain for the given symbol, trading date, and expiration date  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_option_chain(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date date:
        :param date expiration:
        :return: OptionChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_option_chain_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_option_chain_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_option_chain_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns option chain for the given symbol, trading date, and expiration date  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_option_chain_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param date date:
        :param date expiration:
        :return: OptionChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'date', 'expiration_date']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_option_chain" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_option_chain`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501
        if 'expiration_date' in params:
            query_params.append(('expiration', params['expiration_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/option-chain/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='contracts' if params.get('return_pandas') else 'OptionChain',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_server_time(self, **kwargs):  # noqa: E501
        """Get the current server time  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_server_time(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_server_time_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_server_time_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_server_time_with_http_info(self, **kwargs):  # noqa: E501
        """Get the current server time  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_server_time_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_server_time" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/servertime', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[7], lock=lambda self: self.cache_locks[7])
    def get_trading_dates(self, symbol, **kwargs):  # noqa: E501
        """Returns actual trading days in specified from/to date range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trading_dates(symbol, async=True)
        >>> result = thread.get()

        :param async bool
        :param str symbol: (required)
        :param date from_date:
        :param date to:
        :return: list[date]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_trading_dates_with_http_info(symbol, **kwargs)  # noqa: E501
        else:
            (data) = self.get_trading_dates_with_http_info(symbol, **kwargs)  # noqa: E501
            return data

    def get_trading_dates_with_http_info(self, symbol, **kwargs):  # noqa: E501
        """Returns actual trading days in specified from/to date range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_trading_dates_with_http_info(symbol, async=True)
        >>> result = thread.get()

        :param async bool
        :param str symbol: (required)
        :param date from_date:
        :param date to:
        :return: list[date]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'from_date', 'to_date']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_trading_dates" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `get_trading_dates`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'symbol' in params:
            path_params['symbol'] = params['symbol']  # noqa: E501

        query_params = []
        if 'from_date' in params:
            query_params.append(('from', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('to', params['to_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/tradingdates/{symbol}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[date]',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[8], lock=lambda self: self.cache_locks[8])
    def is_trading_day(self, **kwargs):  # noqa: E501
        """Returns true if the day is a trading day, false otherwise  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.is_trading_day(async=True)
        >>> result = thread.get()

        :param async bool
        :param date date:
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.is_trading_day_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.is_trading_day_with_http_info(**kwargs)  # noqa: E501
            return data

    def is_trading_day_with_http_info(self, **kwargs):  # noqa: E501
        """Returns true if the day is a trading day, false otherwise  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.is_trading_day_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param date date:
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['date']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_trading_day" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/trading-day', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[9], lock=lambda self: self.cache_locks[9])
    def get_vertically_sliced_option_chain_by_delta(self, name, **kwargs):  # noqa: E501
        """Returns vertical slice of option chain for the given symbol, option type, trading date, expiration, and the delta strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_vertically_sliced_option_chain_by_delta(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date date:
        :param date expiration:
        :return: OptionChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_vertically_sliced_option_chain_by_delta_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vertically_sliced_option_chain_by_delta_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_vertically_sliced_option_chain_by_delta_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns vertical slice of option chain for the given symbol, option type, trading date, expiration, and the delta strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_vertically_sliced_option_chain_by_delta_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date date:
        :param date expiration:
        :return: OptionChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        all_params = ['name', 'contract_type', 'from_strike', 'to_strike', 'date', 'expiration_date']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vertically_sliced_option_chain_by_delta" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_vertically_sliced_option_chain_by_delta`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'contract_type' in params:
            query_params.append(('contract_type', params['contract_type']))  # noqa: E501
        if 'from_strike' in params:
            query_params.append(('from_strike', params['from_strike']))  # noqa: E501
        if 'to_strike' in params:
            query_params.append(('to_strike', params['to_strike']))  # noqa: E501
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501
        if 'expiration_date' in params:
            query_params.append(('expiration', params['expiration_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/option-chain/{name}/vertical-slice-by-delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='contracts' if params.get('return_pandas') else 'OptionChain',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[10], lock=lambda self: self.cache_locks[10])
    def get_vertically_sliced_option_chain_by_strike(self, name, **kwargs):  # noqa: E501
        """Returns vertical slice of option chain for the given symbol, option type, trading date, expiration, and the strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_vertically_sliced_option_chain_by_strike(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date date:
        :param date expiration:
        :return: OptionChain
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_vertically_sliced_option_chain_by_strike_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vertically_sliced_option_chain_by_strike_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_vertically_sliced_option_chain_by_strike_with_http_info(self, name, **kwargs):  # noqa: E501
        """Returns vertical slice of option chain for the given symbol, option type, trading date, expiration, and the strike range  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_vertically_sliced_option_chain_by_strike_with_http_info(name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param bool contract_type:
        :param float from_strike:
        :param float to_strike:
        :param date date:
        :param date expiration:
        :return: OptionChain
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'contract_type', 'from_strike', 'to_strike', 'date', 'expiration_date']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vertically_sliced_option_chain_by_strike" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_vertically_sliced_option_chain_by_strike`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'contract_type' in params:
            query_params.append(('contract_type', params['contract_type']))  # noqa: E501
        if 'from_strike' in params:
            query_params.append(('from_strike', params['from_strike']))  # noqa: E501
        if 'to_strike' in params:
            query_params.append(('to_strike', params['to_strike']))  # noqa: E501
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501
        if 'expiration_date' in params:
            query_params.append(('expiration', params['expiration_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/option-chain/{name}/vertical-slice-by-strike', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='contracts' if params.get('return_pandas') else 'OptionChain',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    @cachedmethod(lambda self: self.caches[11], lock=lambda self: self.cache_locks[11], key=skew_hashkey)
    def get_volatility_skew(self, **kwargs):  # noqa: E501
        """Returns volatility skews for the given trading symbol, the expiration and the observation dates  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_volatility_skew(async=True)
        >>> result = thread.get()

        :param async bool
        :param str symbol:
        :param list[date] expirations:
        :param list[date] date:
        :return: list[IVSkew]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_volatility_skew_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_volatility_skew_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_volatility_skew_with_http_info(self, **kwargs):  # noqa: E501
        """Returns volatility skews for the given trading symbol, the expiration and the observation dates  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_volatility_skew_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str symbol:
        :param list[date] expirations:
        :param list[date] date:
        :return: list[IVSkew]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'expirations', 'date']  # noqa: E501
        all_params.append('async')
        all_params.append('return_pandas')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_volatility_skew" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'expirations' in params:
            query_params.append(('expirations', params['expirations']))  # noqa: E501
            collection_formats['expirations'] = 'multi'  # noqa: E501
        if 'date' in params:
            query_params.append(('date', params['date']))  # noqa: E501
            collection_formats['date'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/iv-skew', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='skew' if params.get('return_pandas') else 'list[IVSkew]',
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', not params.get('return_pandas')),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_tickers(self, **kwargs):  # noqa: E501
        """Searchs for symbols in the system with an optional query parameter. If query parameter is not used all symbols are returned  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_tickers(async=True)
        >>> result = thread.get()

        :param async bool
        :param str query:
        :return: list[Ticker]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_tickers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_tickers_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_tickers_with_http_info(self, **kwargs):  # noqa: E501
        """Searchs for symbols in the system with an optional query parameter. If query parameter is not used all symbols are returned  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_tickers_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str query:
        :return: list[Ticker]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_tickers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/marketdata/tickers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Ticker]',  # noqa: E501
            auth_settings=auth_settings,
            is_async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
