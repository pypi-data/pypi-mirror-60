# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['returns',
 'returns._generated',
 'returns._generated.converters',
 'returns._generated.pipeline',
 'returns._generated.pointfree',
 'returns.context',
 'returns.contrib',
 'returns.contrib.mypy',
 'returns.primitives']

package_data = \
{'': ['*']}

install_requires = \
['typing-extensions>=3.7,<4.0']

setup_kwargs = {
    'name': 'returns',
    'version': '0.13.0',
    'description': 'Make your functions return something meaningful, typed, and safe!',
    'long_description': '[![Returns logo](https://raw.githubusercontent.com/dry-python/brand/master/logo/returns.png)](https://github.com/dry-python/returns)\n\n-----\n\n[![Build Status](https://travis-ci.com/dry-python/returns.svg?branch=master)](https://travis-ci.com/dry-python/returns)\n[![Coverage Status](https://coveralls.io/repos/github/dry-python/returns/badge.svg?branch=master)](https://coveralls.io/github/dry-python/returns?branch=master)\n[![Documentation Status](https://readthedocs.org/projects/returns/badge/?version=latest)](https://returns.readthedocs.io/en/latest/?badge=latest)\n[![Python Version](https://img.shields.io/pypi/pyversions/returns.svg)](https://pypi.org/project/returns/)\n[![wemake-python-styleguide](https://img.shields.io/badge/style-wemake-000000.svg)](https://github.com/wemake-services/wemake-python-styleguide)\n[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)\n\n-----\n\nMake your functions return something meaningful, typed, and safe!\n\n\n## Features\n\n- Provides a bunch of primitives to write declarative business logic\n- Enforces better architecture\n- Fully typed with annotations and checked with `mypy`, [PEP561 compatible](https://www.python.org/dev/peps/pep-0561/)\n- Has a bunch of helpers for better composition\n- Pythonic and pleasant to write and to read 🐍\n- Support functions and coroutines, framework agnostic\n- Easy to start: has lots of docs, tests, and tutorials\n\n\n## Installation\n\n```bash\npip install returns\n```\n\nYou might also want to [configure](https://returns.readthedocs.io/en/latest/pages/container.html#type-safety)\n`mypy` correctly and install our plugin\nto fix [this existing issue](https://github.com/python/mypy/issues/3157):\n\n```ini\n# In setup.cfg or mypy.ini:\n[mypy]\nplugins =\n  returns.contrib.mypy.decorator_plugin\n```\n\nWe also recommend to use the same `mypy` settings [we use](https://github.com/wemake-services/wemake-python-styleguide/blob/master/styles/mypy.toml).\n\nMake sure you know how to get started, [check out our docs](https://returns.readthedocs.io/en/latest/)!\n\n\n## Contents\n\n- [Maybe container](#maybe-container) that allows you to write `None`-free code\n- [RequiresContext container](#requirescontext-container) that allows you to use typed functional dependency injection\n- [Result container](#result-container) that let\'s you to get rid of exceptions\n- [IO marker](#io-marker) and [IOResult](#troublesome-io) that marks all impure operations and structures them\n\n\n## Maybe container\n\n`None` is called the [worst mistake in the history of Computer Science](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/).\n\nSo, what can we do to check for `None` in our programs?\nYou can use builtin [Optional](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type) type\nand write a lot of `if some is not None:` conditions.\nBut, **having `null` checks here and there makes your code unreadable**.\n\n```python\nuser: Optional[User]\n\nif user is not None:\n     balance = user.get_balance()\n     if balance is not None:\n         balance_credit = balance.credit_amount()\n         if balance_credit is not None and balance_credit > 0:\n             can_buy_stuff = True\nelse:\n    can_buy_stuff = False\n```\n\nOr you can use\n[Maybe](https://returns.readthedocs.io/en/latest/pages/maybe.html) container!\nIt consists of `Some` and `Nothing` types,\nrepresenting existing state and empty (instead of `None`) state respectively.\n\n```python\nfrom typing import Optional\nfrom returns.maybe import Maybe, maybe\n\n@maybe  # decorator to convert existing Optional[int] to Maybe[int]\ndef bad_function() -> Optional[int]:\n    ...\n\nmaybe_result: Maybe[float] = bad_function().map(\n    lambda number: number / 2,\n)\n# => Maybe will return Some[float] only if there\'s a non-None value\n#    Otherwise, will return Nothing\n```\n\nYou can be sure that `.map()` method won\'t be called for `Nothing`.\nForget about `None`-related errors forever!\n\nAnd that\'s how your initial refactored code will look like:\n\n```python\nuser: Optional[User]\n\ncan_buy_stuff: Maybe[bool] = Maybe.new(user).map(  # type hint is not required\n    lambda real_user: real_user.get_balance(),\n).map(\n    lambda balance: balance.credit_amount(),\n).map(\n    lambda balance_credit: balance_credit > 0,\n)\n```\n\nMuch better, isn\'t it?\n\n\n## RequiresContext container\n\nMany developers do use some kind of [dependency injection](https://github.com/dry-python/dependencies) in Python.\nAnd usually it is based on the idea\nthat there\'s some kind of a container and assembly process.\n\nFunctional approach is much simplier!\n\nImagine that you have a `django` based game, where you award users with points for each guessed letter in a word (unguessed letters are marked as `\'.\'`):\n\n```python\nfrom django.http import HttpRequest, HttpResponse\nfrom words_app.logic import calculate_points\n\ndef view(request: HttpRequest) -> HttpResponse:\n    user_word: str = request.POST[\'word\']  # just an example\n    points = calculate_points(user_word)\n    ...  # later you show the result to user somehow\n\n# Somewhere in your `words_app/logic.py`:\n\ndef calculate_points(word: str) -> int:\n    guessed_letters_count = len([letter for letter in word if letter != \'.\'])\n    return _award_points_for_letters(guessed_letters_count)\n\ndef _award_points_for_letters(guessed: int) -> int:\n    return 0 if guessed < 5 else guessed  # minimum 6 points possible!\n```\n\nAwesome! It works, users are happy, your logic is pure and awesome.\nBut, later you decide to make the game more fun:\nlet\'s make the minimal accoutable letters threshold\nconfigurable for an extra challenge.\n\nYou can just do it directly:\n\n```python\ndef _award_points_for_letters(guessed: int, threshold: int) -> int:\n    return 0 if guessed < threshold else guessed\n```\n\nThe problem is that `_award_points_for_letters` is deeply nested.\nAnd then you have to pass `threshold` through the whole callstack,\nincluding `calculate_points` and all other functions that might be on the way.\nAll of them will have to accept `threshold` as a parameter!\nThis is not useful at all!\nLarge code bases will struggle a lot from this change.\n\nOk, you can directly use `django.settings` (or similar)\nin your `_award_points_for_letters` function.\nAnd **ruin your pure logic with framework specific details**. That\'s ugly!\n\nOr you can use `RequiresContext` container. Let\'s see how our code changes:\n\n```python\nfrom django.conf import settings\nfrom django.http import HttpRequest, HttpResponse\nfrom words_app.logic import calculate_points\n\ndef view(request: HttpRequest) -> HttpResponse:\n    user_word: str = request.POST[\'word\']  # just an example\n    points = calculate_points(user_words)(settings)  # passing the dependencies\n    ...  # later you show the result to user somehow\n\n# Somewhere in your `words_app/logic.py`:\n\nfrom typing_extensions import Protocol\nfrom returns.context import RequiresContext\n\nclass _Deps(Protocol):  # we rely on abstractions, not direct values or types\n    WORD_THRESHOLD: int\n\ndef calculate_points(word: str) -> RequiresContext[_Deps, int]:\n    guessed_letters_count = len([letter for letter in word if letter != \'.\'])\n    return _award_points_for_letters(guessed_letters_count)\n\ndef _award_points_for_letters(guessed: int) -> RequiresContext[_Deps, int]:\n    return RequiresContext(\n        lambda deps: 0 if guessed < deps.WORD_THRESHOLD else guessed,\n    )\n```\n\nAnd now you can pass your dependencies in a really direct and explicit way.\nAnd have the type-safety to check what you pass to cover your back.\nCheck out [RequiresContext](https://returns.readthedocs.io/en/latest/pages/context.html) docs for more. There you will learn how to make `\'.\'` also configurable.\n\nWe also have [RequiresContextResult](https://returns.readthedocs.io/en/latest/pages/context.html#requirescontextresult-container)\nfor context-related operations that might fail.\n\n\n## Result container\n\nPlease, make sure that you are also aware of\n[Railway Oriented Programming](https://fsharpforfunandprofit.com/rop/).\n\n### Straight-forward approach\n\nConsider this code that you can find in **any** `python` project.\n\n```python\nimport requests\n\ndef fetch_user_profile(user_id: int) -> \'UserProfile\':\n    """Fetches UserProfile dict from foreign API."""\n    response = requests.get(\'/api/users/{0}\'.format(user_id))\n    response.raise_for_status()\n    return response.json()\n```\n\nSeems legit, does not it?\nIt also seems like a pretty straight forward code to test.\nAll you need is to mock `requests.get` to return the structure you need.\n\nBut, there are hidden problems in this tiny code sample\nthat are almost impossible to spot at the first glance.\n\n### Hidden problems\n\nLet\'s have a look at the exact same code,\nbut with the all hidden problems explained.\n\n```python\nimport requests\n\ndef fetch_user_profile(user_id: int) -> \'UserProfile\':\n    """Fetches UserProfile dict from foreign API."""\n    response = requests.get(\'/api/users/{0}\'.format(user_id))\n\n    # What if we try to find user that does not exist?\n    # Or network will go down? Or the server will return 500?\n    # In this case the next line will fail with an exception.\n    # We need to handle all possible errors in this function\n    # and do not return corrupt data to consumers.\n    response.raise_for_status()\n\n    # What if we have received invalid JSON?\n    # Next line will raise an exception!\n    return response.json()\n```\n\nNow, all (probably all?) problems are clear.\nHow can we be sure that this function will be safe\nto use inside our complex business logic?\n\nWe really can not be sure!\nWe will have to create **lots** of `try` and `except` cases\njust to catch the expected exceptions.\n\nOur code will become complex and unreadable with all this mess!\n\n### Pipe example\n\n```python\nimport requests\nfrom returns.result import Result, safe\nfrom returns.pipeline import flow\nfrom returns.pointfree import bind\n\ndef fetch_user_profile(user_id: int) -> Result[\'UserProfile\', Exception]:\n    """Fetches `UserProfile` TypedDict from foreign API."""\n    return flow(\n        user_id,\n        _make_request,\n        bind(_parse_json),\n    )\n\n@safe\ndef _make_request(user_id: int) -> requests.Response:\n    # TODO: we are not yet done with this example, read more about `IO`:\n    response = requests.get(\'/api/users/{0}\'.format(user_id))\n    response.raise_for_status()\n    return response\n\n@safe\ndef _parse_json(response: requests.Response) -> \'UserProfile\':\n    return response.json()\n```\n\nNow we have a clean and a safe and declarative way\nto express our business needs:\n\n- We start from making a request, that might fail at any moment,\n- Then parsing the response if the request was successful,\n- And then return the result.\n\nNow, instead of returning regular values\nwe return values wrapped inside a special container\nthanks to the\n[@safe](https://returns.readthedocs.io/en/latest/pages/result.html#safe)\ndecorator. It will return [Success[YourType] or Failure[Exception]](https://returns.readthedocs.io/en/latest/pages/result.html).\nAnd will never throw exception at us!\n\nWe also use [flow](https://returns.readthedocs.io/en/latest/pages/pipeline.html#flow)\nand [bind](https://returns.readthedocs.io/en/latest/pages/pointfree.html#bind)\nfunctions for handy and declarative composition.\n\nThis way we can be sure that our code won\'t break in\nrandom places due to some implicit exception.\nNow we control all parts and are prepared for the explicit errors.\n\nWe are not yet done with this example,\nlet\'s continue to improve it in the next chapter.\n\n\n## IO marker\n\nLet\'s look at our example from another angle.\nAll its functions look like regular ones:\nit is impossible to tell whether they are [pure](https://en.wikipedia.org/wiki/Pure_function)\nor impure from the first sight.\n\nIt leads to a very important consequence:\n*we start to mix pure and impure code together*.\nWe should not do that!\n\nWhen these two concepts are mixed\nwe suffer really bad when testing or reusing it.\nAlmost everything should be pure by default.\nAnd we should explicitly mark impure parts of the program.\n\nThat\'s why we have created `IO` marker\nto mark impure functions that never fail.\n\nThese impure functions use `random`, current datetime, environment, or console:\n\n```python\nimport random\nimport datetime as dt\n\nfrom returns.io import IO\n\ndef get_random_number() -> IO[int]:  # or use `@impure` decorator\n    return IO(random.randint(1, 10))  # isn\'t pure, because random\n\nnow: Callable[[], IO[dt.datetime]] = impure(dt.datetime.now)\n\n@impure\ndef return_and_show_next_number(previous: int) -> int:\n    next_number = previous + 1\n    print(next_number)  # isn\'t pure, because does IO\n    return next_number\n```\n\nNow we can clearly see which functions are pure and which ones are impure.\nThis helps us a lot in building large applications, unit testing you code,\nand composing bussiness logic together.\n\n### Troublesome IO\n\nAs it was already said, we use `IO` when we handle functions that do not fail.\n\nWhat if our function can fail and is impure?\nLike `requests.get()` we had earlier in your example.\n\nThen we have to use `IOResult` instead of a regular `Result`.\nLet\'s find the difference:\n\n- Our `_parse_json` function always return\n  the same result (hopefully) for the same input:\n  you can either parse valid `json` or fail on invalid one.\n  That\'s why we return pure `Result`\n- Our `_make_request` function is impure and can fail.\n  Try to send two similar requests with and without internet connection.\n  The result will be different for the same input.\n  That\'s why we must use `IOResult` here\n\nSo, in order to fulfill our requirement and separate pure code from impure one,\nwe have to refactor our example.\n\n### Explicit IO\n\nLet\'s make our [IO](https://returns.readthedocs.io/en/latest/pages/io.html)\nexplicit!\n\n```python\nimport requests\nfrom returns.io import IO, IOResult, impure_safe\nfrom returns.result import safe\nfrom returns.pipeline import flow\nfrom returns.pointfree import bind\n\ndef fetch_user_profile(user_id: int) -> IOResult[\'UserProfile\', Exception]:\n    """Fetches `UserProfile` TypedDict from foreign API."""\n    return flow(\n        user_id,\n        _make_request,\n        # before: def (Response) -> UserProfile\n        # after safe: def (Response) -> ResultE[UserProfile]\n        # after bind: def (ResultE[Response]) -> ResultE[UserProfile]\n        # after lift: def (IOResultE[Response]) -> IOResultE[UserProfile]\n        IOResult.lift_result(bind(_parse_json)),\n    )\n\n@impure_safe\ndef _make_request(user_id: int) -> requests.Response:\n    response = requests.get(\'/api/users/{0}\'.format(user_id))\n    response.raise_for_status()\n    return response\n\n@safe\ndef _parse_json(response: requests.Response) -> \'UserProfile\':\n    return response.json()\n```\n\nAnd latter we can [unsafe_perform_io](https://returns.readthedocs.io/en/latest/pages/io.html#unsafe-perform-io)\nsomewhere at the top level of our program to get the pure value.\n\nAs a result of this refactoring session, we know everything about our code:\n\n- Which parts can fail,\n- Which parts are impure,\n- How to compose them in a smart manner.\n\n\n## More!\n\nWant more? [Go to the docs!](https://returns.readthedocs.io)\nOr read these articles:\n\n- [Python exceptions considered an anti-pattern](https://sobolevn.me/2019/02/python-exceptions-considered-an-antipattern)\n- [Enforcing Single Responsibility Principle in Python](https://sobolevn.me/2019/03/enforcing-srp)\n- [Typed functional Dependency Injection in Python](https://sobolevn.me/2020/02/typed-functional-dependency-injection)\n\nDo you have an article to submit? Feel free to open a pull request!\n',
    'author': 'sobolevn',
    'author_email': 'mail@sobolevn.me',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://returns.readthedocs.io',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
