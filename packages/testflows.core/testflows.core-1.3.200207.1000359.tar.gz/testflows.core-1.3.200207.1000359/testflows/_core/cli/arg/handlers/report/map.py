# Copyright 2020 Vitaliy Zakaznikov (TestFlows Test Framework http://testflows.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import os
import sys
import json
import time
import base64

from datetime import datetime

import testflows._core.cli.arg.type as argtype

from testflows._core import __version__
from testflows._core.cli.arg.common import epilog
from testflows._core.cli.arg.common import HelpFormatter
from testflows._core.cli.arg.handlers.handler import Handler as HandlerBase
from testflows._core.cli.arg.handlers.report.copyright import copyright
from testflows._core.transform.log.pipeline import MapLogPipeline
from testflows._core.transform.log.message import RawMap
from testflows._core.utils.timefuncs import localfromtimestamp, strftimedelta

logo = '<img class="logo" src="data:image/png;base64,%(data)s" alt="logo"/>'
testflows = '<span class="testflows-logo"></span> [<span class="logo-test">Test</span><span class="logo-flows">Flows</span>]'
testflows_em = testflows.replace("[", "").replace("]", "")

template = f"""
<section class="clearfix">%(logo)s%(confidential)s%(copyright)s</section>

---
# Test Map Report
%(body)s
  
---
Generated by {testflows} Open-Source Test Framework

[<span class="logo-test">Test</span><span class="logo-flows">Flows</span>]: https://testflows.com
[ClickHouse]: https://clickhouse.yandex
"""

map_style = """
.node circle {
  cursor: pointer;
  stroke: #3182bd;
  stroke-width: 1.5px;
}

.node text {
  font: 10px sans-serif;
  pointer-events: none;
  text-anchor: middle;
}

line.link {
  fill: none;
  stroke: #9ecae1;
  stroke-width: 1.5px;
}
"""

map_script = """
function update(data) {
  const links = data.links.map(d => Object.create(d));
  const nodes = data.nodes.map(d => Object.create({id: d}));

  const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id))
      .force("charge", d3.forceManyBody().strength(-1400))
      .force("x", d3.forceX())
      .force("y", d3.forceY());

  const svg = d3.select("#map-chart").select("svg");

  // Per-type markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
      .data(types)
      .join("marker")
      .attr("id", d => `arrow-${d}`)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 33)
      .attr("refY", -2.5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("fill", color)
      .attr("d", "M0,-5L10,0L0,5");

  const link = svg.append("g")
      .attr("fill", "none")
      .attr("stroke-width", 1.5)
      .selectAll("path")
      .data(links)
      .join("path")
      .attr("stroke", d => color(d.type))
      .attr("marker-end", d => `url(${new URL(`#arrow-${d.type}`, location)})`);

  const node = svg.append("g")
      .attr("fill", "currentColor")
      .attr("stroke-linecap", "round")
      .attr("stroke-linejoin", "round")
      .selectAll("g")
      .data(nodes)
      .join("g")
      .call(drag(simulation));

  node.append("circle")
      .attr("stroke", "#b5b5fb")
      .attr("fill", "white")
      .attr("stroke-width", 1.5)
      .attr("r", 20);

  node.append("text")
      .attr("x", 25)
      .attr("y", "0.31em")
      .text(d => d.id)
      .clone(true).lower()
      .attr("fill", "none")
      .attr("stroke", "white")
      .attr("stroke-width", 3);

  simulation.on("tick", () => {
    link.attr("d", linkArc);
    node.attr("transform", d => `translate(${d.x},${d.y})`);
  });

  //invalidation.then(() => simulation.stop());

  return svg.node();
};
var links = [
    {"source":"Microsoft","target":"Amazon","type":"licensing"},
    {"source":"Microsoft","target":"HTC","type":"licensing"},
    {"source":"Samsung","target":"Apple","type":"suit"},
    {"source":"Motorola","target":"Apple","type":"suit"},
    {"source":"Nokia","target":"Apple","type":"resolved"},
    {"source":"HTC","target":"Apple","type":"suit"},
    {"source":"Kodak","target":"Apple","type":"suit"},
    {"source":"Microsoft","target":"Barnes & Noble","type":"suit"},
    {"source":"Microsoft","target":"Foxconn","type":"suit"},
    {"source":"Oracle","target":"Google","type":"suit"},
    {"source":"Apple","target":"HTC","type":"suit"},
    {"source":"Microsoft","target":"Inventec","type":"suit"},
    {"source":"Samsung","target":"Kodak","type":"resolved"},
    {"source":"LG","target":"Kodak","type":"resolved"},
    {"source":"RIM","target":"Kodak","type":"suit"},
    {"source":"Sony","target":"LG","type":"suit"},
    {"source":"Kodak","target":"LG","type":"resolved"},
    {"source":"Apple","target":"Nokia","type":"resolved"},
    {"source":"Qualcomm","target":"Nokia","type":"resolved"},
    {"source":"Apple","target":"Motorola","type":"suit"},
    {"source":"Microsoft","target":"Motorola","type":"suit"},
    {"source":"Motorola","target":"Microsoft","type":"suit"},
    {"source":"Huawei","target":"ZTE","type":"suit"},
    {"source":"Ericsson","target":"ZTE","type":"suit"},
    {"source":"Kodak","target":"Samsung","type":"resolved"},
    {"source":"Apple","target":"Samsung","type":"suit"},
    {"source":"Kodak","target":"RIM","type":"suit"},
    {"source":"Nokia","target":"Qualcomm","type":"suit"},
    {"source":"Nokia","target":"Nokia","type":"suit"},
    ]

var links = %(links)s;
var types = Array.from(new Set(links.map(d => d.type)));
//var nodes = Array.from(new Set(links.flatMap(l => [l.source, l.target])), id => ({id})); 
var nodes = Array.from(new Set(%(nodes)s));
var data = {nodes: nodes, links: links};
//var color = d3.scaleOrdinal(types, d3.schemeCategory10);
var color = function(type) {
    if (type == "link") {
        return "blue";
    }
    else {
        return "orange";
    }
};

const width = 950,
    height = 800;

const svg = d3.select("#map-chart").append("svg")
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .style("font", "12px sans-serif");

function linkArc(d) {
  const r = Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);
  return `
    M${d.source.x},${d.source.y}
    A${r},${r} 0 0,1 ${d.target.x},${d.target.y}
  `;
}

var drag = function(simulation) {
  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  
  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }
  
  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
  
  return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
};

window.onload = function() {
  update(data);
};

"""

class Formatter:
    def format_logo(self, data):
        if not data["company"].get("logo"):
            return ""
        data = base64.b64encode(data["company"]["logo"]).decode("utf-8")
        return '\n<p>' + logo % {"data": data} + "</p>\n"

    def format_confidential(self, data):
        if not data["company"].get("confidential"):
            return ""
        return f'\n<p class="confidential">Document status - Confidential</p>\n'

    def format_copyright(self, data):
        if not data["company"].get("name"):
            return ""
        return (f'\n<p class="copyright">\n'
            f'{copyright(data["company"]["name"])}\n'
            "</p>\n")

    def format_metadata(self, data):
        metadata = data["metadata"]
        s = (
            "\n\n"
            f"||**Date**||{localfromtimestamp(metadata['date']):%b %d, %Y %-H:%M}||\n"
            f'||**Framework**||'
            f'{testflows} {metadata["version"]}||\n'
        )
        return s + "\n"

    def format_map(self, data):

        def make_node(nodes, maps):
            if not isinstance(maps, RawMap):
                maps = RawMap(*maps)

            if maps.node not in nodes:
                nodes[maps.node] = {
                    "name": maps.node,
                    "nexts": [],
                    "ins": [],
                    "outs": []
                }
            return nodes[maps.node]

        def generate_nodes(nodes, maps):
            if not isinstance(maps, RawMap):
                maps = RawMap(*maps)

            node = make_node(nodes, maps)

            if maps.nexts:
                [nodes[maps.node]["nexts"].append(generate_nodes(nodes, n)) for n in maps.nexts]
            if maps.ins:
                [nodes[maps.node]["ins"].append(generate_nodes(nodes, n)) for n in maps.ins]
            if maps.outs:
                [nodes[maps.node]["outs"].append(generate_nodes(nodes, n)) for n in maps.outs]

            return node

        def gather_links(nodes):
            links = []
            for node in nodes.values():
                for n in node["nexts"]:
                    links.append({"source": node["name"], "target": n["name"], "type": "link"})
                for n in node["ins"]:
                    links.append({"source": node["name"], "target": n["name"], "type": "inner link"})
                for n in node["outs"]:
                    links.append({"source": n["name"], "target": node["name"], "type": "inner link"})
            return links

        nodes = {}
        generate_nodes(nodes, data["map"])
        links = gather_links(nodes)
        chart_nodes = json.dumps(list(nodes.keys()), indent=2)
        chart_links = json.dumps(links, indent=2)

        s = (
            '\n##Steps Diagram\n\n'
            '<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.15.0/d3.js"></script>\n'
            '<style>\n'
            f'{map_style}\n'
            '</style>\n'
            '<div><div id="map-chart"></div></div>\n'
            '<script>\n'
            f'{map_script % {"nodes": chart_nodes, "links": chart_links}}\n'
            '</script>\n'
        )
        return s + "\n"

    def format(self, data):
        body = ""
        body += self.format_metadata(data)
        body += self.format_map(data)
        return template.strip() % {
            "logo": self.format_logo(data),
            "confidential": self.format_confidential(data),
            "copyright": self.format_copyright(data),
            "body": body}

class Handler(HandlerBase):
    @classmethod
    def add_command(cls, commands):
        parser = commands.add_parser("map", help="map report", epilog=epilog(),
            description="Generate map report.",
            formatter_class=HelpFormatter)

        parser.add_argument("input", metavar="input", type=argtype.file("r", bufsize=1, encoding="utf-8"),
                nargs="?", help="input log, default: stdin", default="-")
        parser.add_argument("output", metavar="output", type=argtype.file("w", bufsize=1, encoding="utf-8"),
                nargs="?", help='output file, default: stdout', default="-")
        parser.add_argument("--format", metavar="type", type=str,
            help="output format, default: md (Markdown)", choices=["md"], default="md")
        parser.add_argument("--copyright", metavar="name", help="add copyright notice", type=str)
        parser.add_argument("--confidential", help="mark as confidential", action="store_true")
        parser.add_argument("--logo", metavar="path", type=argtype.file("rb"),
                help='use logo image (.png)')

        parser.set_defaults(func=cls())

    def metadata(self, results):
        return {
            "date": time.time(),
            "version": __version__,
        }

    def company(self, args):
        d = {}
        if args.copyright:
            d["name"] = args.copyright
        if args.confidential:
            d["confidential"] = True
        if args.logo:
            d["logo"] = args.logo.read()
        return d

    def data(self, maps, args):
        d = dict()
        d["metadata"] = self.metadata(maps)
        d["company"] = self.company(args)
        d["map"] = maps["top"]
        return d

    def generate(self, formatter, maps, args):
        output = args.output
        output.write(
            formatter.format(self.data(maps, args))
        )
        output.write("\n")

    def handle(self, args):
        maps = {}
        formatter = Formatter()
        MapLogPipeline(args.input, maps).run()
        self.generate(formatter, maps, args)
