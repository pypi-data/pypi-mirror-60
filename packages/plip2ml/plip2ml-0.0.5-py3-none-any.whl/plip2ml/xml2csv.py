"""Convert PLIP xml output to csv file.

This module provides a function to convert a "report.xml" file generated by PLIP to a "report.csv" file
"""

from lxml import etree
import pandas as pd


# Utility data
# ---------------------------------------------------------------------------------------------------------------

plip_interaction_names = ['hydrophobic_interactions', 'hydrogen_bonds',
                          # 'water_bridges', # None in my dataset.
                          'salt_bridges', 'pi_stacks', 'pi_cation_interactions', 'halogen_bonds', 'metal_complexes']

plip_interaction_property_boolean = ['sidechain', 'protisdon', 'protispos', 'protcharged']

plip_interaction_property_float = ['dist', 'dist_h-a', 'dist_d-a', 'don_angle', 'centdist', 'angle', 'offset',
                                   'acc_angle', 'rms']

plip_interaction_property_integer = ['coordination', 'complexnum']

plip_interaction_property_string = ['restype', 'restype_lig', 'donortype', 'acceptortype', 'lig_group', 'type',
                                    'metal_type', 'target_type', 'location', 'geometry']

plip_interaction_property_names = plip_interaction_property_boolean + plip_interaction_property_float + plip_interaction_property_integer + plip_interaction_property_string

plip_lig_property_integer = ['num_heavy_atoms', 'num_hbd', 'num_unpaired_hbd', 'num_hba', 'num_unpaired_hba', 'num_hal',
                             'num_unpaired_hal', 'num_aromatic_rings', 'num_rotatable_bonds']

plip_lig_property_float = ['molweight', 'logp']

plip_lig_property_names = plip_lig_property_integer + plip_lig_property_float


def compute_cells(text_dict, booleans=None, floats=None, integers=None, strings=None):
    """
    Compute a row of values, using data types.

    Args:
        booleans:
        floats:
        integers:
        strings:

    Returns:
        A python lists of values
    """
    if strings is None:
        strings = []
    if integers is None:
        integers = []
    if floats is None:
        floats = []
    if booleans is None:
        booleans = []
    row = list()
    for name in booleans:
        row.append(bool(text_dict[name]) if name in text_dict else None)
    for name in floats:
        row.append(float(text_dict[name]) if name in text_dict else None)
    for name in integers:
        row.append(int(text_dict[name]) if name in text_dict else None)
    for name in strings:
        row.append(str(text_dict[name]) if name in text_dict else None)
    return row


def get_bindingsite_elts(plipxml):
    """
    Parse a plipxml report.xml file and returns the list of bindingsite xml elements.

    The <bindingsite> xml tag is directly under the root.

    Args:
        plipxml: PLIP output report.xml file path

    Returns:
        A list of xml elements.
    """
    return [bs for bs in etree.parse(plipxml).getroot().iterchildren('bindingsite')]


def compute_text_dict(elt):
    """
    Parse and xml element and return a dict of tag:text of its children

    Args:
        elt: xml element

    Returns:
        dict str -> str
    """
    return {elt.tag: elt.text for elt in elt.iterchildren()}


def get_ligand_residues(bs_elt):
    """
    Parse the ligand_id for the given binding site.

    Args:
        ligand_elts: Ligand xml elements.

    Returns:
        A string containing the ligand_id, formatted as "chain.resname.resnum[-chain.resname.resnum[...]]"
    """
    ligand_elts = [elt for elt in next(next(bs_elt.iterchildren('identifiers')).iterchildren('members')).iterchildren()]
    residues = list()
    for member in ligand_elts:
        res_name, chain_id, res_num = member.text.split(':')
        residues.append('%s.%s.%s' % (chain_id, res_name, res_num))
    return '-'.join(residues)


def get_lig_properties_elt(bs_elt):
    """
    lig_properties xml element
    """
    return next(bs_elt.iterchildren('lig_properties'))


def get_interaction_elts(bs_elt):
    """
    PLIP interactions xml elements
    """
    elts = list()
    for interaction_type in next(bs_elt.iterchildren('interactions')).iterchildren():
        for interaction in interaction_type.iterchildren():
            elts.append(interaction)
    return elts


def compute_plipcsv_rows(plipxml, structrure_id=None, ligand_residues=None):
    """
    Compute the rows of the plipcsv.

    Args:
        plipxml: plipxml report.xml file
        structrure_id: structure_id to identify the complexes
        ligand_residues: ligands selection, keep all ligands if None. List of 2 example: ["D.NDG.205-D.GAL.206-D.A2G.207","D.NDG.205"]'

    Returns:
        A list of row, each row as a python list
    """
    rows = list()
    for bs_elt in get_bindingsite_elts(plipxml):
        ligand_id = get_ligand_residues(bs_elt)
        if ligand_residues is None or ligand_id == ligand_residues or ligand_id in ligand_residues:
            lig_properties_elt = get_lig_properties_elt(bs_elt)
            lig_properties_dict = compute_text_dict(lig_properties_elt)
            lig_properties_cells = compute_cells(lig_properties_dict, floats=plip_lig_property_float,
                                                 integers=plip_lig_property_integer)
            common_cells = [structrure_id, ligand_id] + lig_properties_cells
            # First row contains only "common" cells (i.e. structure id and ligand info)
            rows.append(common_cells + ['lig_properties'] + [None] * len(plip_interaction_property_names))

            for interaction_elt in get_interaction_elts(bs_elt):
                interaction_dict = compute_text_dict(interaction_elt)
                interaction_cells = compute_cells(interaction_dict,
                                                  booleans=plip_interaction_property_boolean,
                                                  floats=plip_interaction_property_float,
                                                  integers=plip_interaction_property_integer,
                                                  strings=plip_interaction_property_string)
                rows.append(common_cells + [interaction_elt.tag] + interaction_cells)
    return rows


def get_plipcsv_columns():
    return ['structure_id', 'ligand_residues'] + plip_lig_property_names + ['interaction'] + plip_interaction_property_names


def compute_plipcsv_df(plipxml, structrure_id=None, ligand_residues=None):
    df = pd.DataFrame(compute_plipcsv_rows(plipxml, structrure_id, ligand_residues), columns=get_plipcsv_columns())
    return df


def generate_plipcsv(plipxml, plipcsv=None, structrure_id=None, ligand_ids=None):
    if plipcsv is None:
        plipcsv = plipxml.replace(".xml", ".csv")
        if not plipcsv.endswith('.csv'): plipcsv = plipxml + '.csv'
    df = compute_plipcsv_df(plipxml, structrure_id, ligand_ids)
    df.to_csv(plipcsv, index=False)

