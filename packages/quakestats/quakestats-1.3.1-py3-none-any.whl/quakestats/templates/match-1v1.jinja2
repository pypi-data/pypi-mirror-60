{% extends "base2.jinja2" %}

{% block body_top %}

<script>

  var fetch_match_kills = qapi.getMatchKills(context.match_guid)
  var fetch_players = qapi.getMatchPlayers(context.match_guid)
  var fetch_match = qapi.getMatch(context.match_guid)
  var fetch_match_scores = qapi.getMatchScores(context.match_guid)
  var fetch_match_teams = qapi.getMatchTeams(context.match_guid)
  var fetch_match_specials = qapi.getMatchSpecial(context.match_guid)
  var fetch_match_player_stats = qapi.getMatchPlayerStats(context.match_guid)

  var dataProc = new QuakeStatsDataProcessor()

  class PlayersState {
    constructor() {
      riot.observable(this)
      this.players = {}
      this.focused = null
    }

    setPlayers(players) {
      this.players = players

      var colorHash = new ColorHash({
        saturation: 0.9,
        lightness: [0.5, 0.6, 0.65],
      })

      for (let player of Object.values(this.players)) {
        player.color = colorHash.hsl(player.id)
      }
    }

    getPlayerColor(playerId) {
      var color = this.getPlayer(playerId).color
      return `hsl(${color[0]}, ${color[1]}, ${color[2]})`
    }

    getPlayer(playerId) {
      return this.players[playerId]
    }

    setFocus(playerId) {
      this.focused = playerId
      this.trigger('player_focused', playerId)
    }
  }
  var playersState = new PlayersState()

  fetch_players.then(json => {
    context.players = dataProc.playersMap(json)
    playersState.setPlayers(context.players)
  })

  Promise.all([fetch_players, fetch_match_kills, fetch_match_scores, fetch_match_specials, fetch_match])
  .then(values => {
    var match_scores = values[2]
    var match_kills = values[1]
    var match_specials = values[3]
    var match_info = values[4]
    match_kills = match_kills.map((e) => {e.by_weapon = weapon_map[e.by] || e.by; return e})

    var enemy_kills = match_kills.filter(function(e)
      {return !isSelfKill(e)}
    )
    var kill_series = d3.nest()
      .key(function(d) {return d.killer_id})
      .entries(enemy_kills)

    var death_series = d3.nest()
      .key(function(d) {return d.victim_id})
      .entries(match_kills)

    kill_series = kill_series.map(function(d) {
      var total=0; return {
        key: d.key,
        values: d.values.map(function(v) {
          total++; v.kills=total; return v
        })
      }
    })
    death_series = death_series.map(function(d) {
      var total=0; return {
        key: d.key,
        values: d.values.map(function(v) {
          total++; v.deaths=total; return v
        })
      }
    })

    var kill_entries = kill_series.map(function(d) {return {
      x: d.values.map(function(d) {return d.game_time}),
      y: d.values.map(function(d) {return d.kills}),
      type: 'scatter',
      mode: 'lines+markers',
      name: `${context.players[d.key].name} (${d.values[d.values.length-1].kills})`,
      line: {color: playersState.getPlayerColor(d.key)},
    }}).sort(function(a, b) {
      return b.y[b.y.length-1] - a.y[a.y.length-1]
    })

    var death_entries = death_series.map(function(d) {return {
      x: d.values.map(function(d) {return d.game_time}),
      y: d.values.map(function(d) {return d.deaths}),
      type: 'scatter',
      mode: 'lines+markers',
      name: `${context.players[d.key].name} (${d.values[d.values.length-1].deaths})`,
      line: {color: playersState.getPlayerColor(d.key)},
    }}).sort(function(a, b) {
      return b.y[b.y.length-1] - a.y[a.y.length-1]
    })


    let chartLayout = {
      height: 400,
      margin: {b: 25, t: 25, l: 20, r: 10},
      hovermode: 'closest',
      legend: {"orientation": "h"},
    }
    riot.mount('match-kills-chart', {'series': kill_entries, 'chartLayout': chartLayout,})
    riot.mount('match-deaths-chart', {'series': death_entries, 'chartLayout': chartLayout,})
    riot.mount('match-kdr-chart', {
      'kills': match_kills, 'players': playersState,
      'chartLayout': chartLayout,
      }
    )

    // weapon stats
    var weapon_kills = d3.nest()
    .key((e) => {return e.killer_id})
    .key((e) => {return e.by_weapon})
    .rollup((v) => {return v.length})
    .object(enemy_kills)

    var weapon_deaths = d3.nest()
    .key((e) => {return e.victim_id})
    .key((e) => {return e.by_weapon})
    .rollup((v) => {return v.length})
    .object(match_kills)

    var weapon_kd = {}
    Object.entries(weapon_kills).forEach(
      ([player_id, stats]) => {
        var stat = {}
        weapon_kd[player_id] = stat;
        Object.entries(stats).forEach(([weapon_name, kills]) => {
          stat[weapon_name] = {"kills": kills}
        })
      })
    Object.entries(weapon_deaths).forEach(
      ([player_id, stats]) => {
        var stat = weapon_kd[player_id] || {}
        weapon_kd[player_id] = stat;
        Object.entries(stats).forEach(([weapon_name, deaths]) => {
          var weapon_stat = stat[weapon_name] || {}
          stat[weapon_name] = weapon_stat
          weapon_stat["deaths"] = deaths
        })
      })

    var weapons = new Set(Object.keys(
      d3.nest()
      .key((e) => {return e.by_weapon})
      .object(match_kills))
    )

    riot.mount('weapon-kills', {
        'player_weapon_kills': weapon_kd,
        'players': playersState,
        'weapons': [...weapons].sort()
    })

    var series = d3.nest().key(function(d) {return d.player_id}).entries(match_scores)
    var score_series = series.map(function(d) {return {
      x: d.values.map(function(d) {return d.game_time}),
      y: d.values.map(function(d) {return d.score}),
      type: 'scatter',
      mode: 'lines+markers',
      name: `${context.players[d.key].name} (${d.values[d.values.length-1].score})`,
      line: {color: playersState.getPlayerColor(d.key)},
    }}).sort(function(a, b) {
      return b.y[b.y.length-1] - a.y[a.y.length-1]
    })

    var enemy_kills_by_id = d3.nest()
      .key((e) => {return e.killer_id})
      .object(match_kills.filter((s) => {return s.killer_id != s.victim_id}))
    var final_scores = series.map(function(d) {
      var last_score = d.values.splice(-1)[0]
      return {
        player_id: d.key,
        score: last_score.score,
        ts: last_score.game_time,
        fav_weapon: (d.key in enemy_kills_by_id) ? d3.nest()
          .key((d) => {return d.by_weapon})
          .rollup((v) => {return v.length})
          .entries(enemy_kills_by_id[d.key])
          .sort((a, b) => {return b.value - a.value})[0].key : null
      }
    }).sort((a, b) => {return (b.score - a.score) || (b.ts - a.ts)})

    var specials_by_type = d3.nest().key((d) => {return d.score_type}).object(match_specials)
    var max_score = final_scores[0].score

    riot.mount('score-summary', {'scores': final_scores, 'players': playersState})
    riot.mount('match-score-chart', {'series': score_series, specials_by_type: specials_by_type, scores: match_scores, 'match_info': match_info, 'max_score': max_score})

    var duelPlayerNames = final_scores
      .filter((e) => {return e.player_id != 'q3-world'})
      .map((e) => {return context.players[e.player_id].name})

    if (duelPlayerNames.length != 2) {
      console.warn("Duel players != 2")
    }
    riot.mount('duel-title', {'matchInfo': match_info, 'players': duelPlayerNames})
  })

  Promise.all([fetch_players, fetch_match_specials])
  .then(values => {
    var json = values[1]
    var specials = d3.nest()
    .key(function(d) {return d.score_type})
    .key(function(d) {return d.killer_id})

    var specials_summary = specials
      .rollup(v => {
        // TODO make some generic mechanism
        if (v[0].score_type == "DREADNOUGHT") {
          if (v.length > 1) { throw "Unexpected value" }
          return {total: Math.round(v[0].value), timestamp: 0}
        }
        return {total: v.length, timestamp: v[v.length-1].game_time}
      })
      .entries(json)

    var specials_details = specials
    .key(function(d) {return d.victim_id})
    .rollup(function(v) {return v.length})
    .entries(json)

    riot.mount('special-scores', {'specials': specials_summary, 'details': specials_details, 'players': playersState})
  })

  Promise.all([fetch_players, fetch_match_kills])
  .then(values => {
    var match_scores = values[2]
    var match_kills = values[1]

    var player_kills = d3.nest()
      .key((d) => {return d.killer_id})
      .key((d) => {return d.victim_id})
      .rollup((v) => {return v.length})
      .entries(match_kills)
      .map((e) => {
        return {player_id: e.key, kills: e.values}
      })
    var player_deaths = d3.nest()
      .key((d) => {return d.victim_id})
      .key((d) => {return d.killer_id})
      .rollup((v) => {return v.length})
      .entries(match_kills)
      .map((e) => {
        return {player_id: e.key, deaths: e.values}
      })

    var kds = {}
		for (entry of player_kills) {
		  var player_info = {}
		  kds[entry.player_id] = player_info
		  for (entry of entry.kills) {
		    player_info[entry.key] = {kills: entry.value, deaths: 0}
		  }
		}
		for (entry of player_deaths) {
      var player_info = kds[entry.player_id]
      if (!player_info) {
        player_info = {}
        kds[entry.player_id] = player_info
      }

      for (entry of entry.deaths) {
        var death_info = player_info[entry.key]
        if (!death_info) {
          player_info[entry.key] = {kills: 0, deaths: entry.value}
        } else {
          death_info.deaths = entry.value
        }
      }
    }

    riot.mount('match-player-kill-death', {'kds': kds, 'players': playersState})
  })

  Promise.all([fetch_match_player_stats, fetch_players])
  .then(values => {
    var stats = values[0]

    riot.mount('accuracy-info', {stats: stats})

    riot.mount('player-damage-summary', {
      "players": playersState,
      "damageDealt":
        stats.reduce((acc, cur) => {
          acc.push([cur.player_id, cur.damage_dealt]); return acc
        }, [])
        .sort((a, b) => {return b[1] - a[1]}),
      "damageTaken":
        stats.reduce((acc, cur) => {
          acc.push([cur.player_id, cur.damage_taken]); return acc
        }, [])
        .sort((a, b) => {return a[1] - b[1]}),
    })


    riot.mount('player-pickup-summary', {
      "players": playersState,
      "totalHealth":
        stats.reduce((acc, cur) => {
          acc.push([cur.player_id, cur.total_health_pickup]); return acc
        }, [])
        .sort((a, b) => {return b[1] - a[1]}),
      "totalArmor":
        stats.reduce((acc, cur) => {
          acc.push([cur.player_id, cur.total_armor_pickup]); return acc
        }, [])
        .sort((a, b) => {return b[1] - a[1]}),
    })
  })

</script>

{% endblock %}

{% block body %}
  <div style="grid-column: 1 / -1; margin-top:25px; background: none;">
    <duel-title></duel-title>
  </div>
  <div style="grid-column: auto / span 2">
    <accuracy-info></accuracy-info>
  </div>
  <div style="grid-column: auto / span 2">
    <score-summary></score-summary>
  </div>
  <div style="grid-column: auto / span 2">
    <weapon-kills></weapon-kills>
  </div>
  <div style="grid-column: 1 / -1">
    <match-score-chart></match-score-chart>
  </div>
  <div style="grid-column: auto / span 3">
    <player-damage-summary></player-damage-summary>
  </div>
  <div style="grid-column: auto / span 3">
    <player-pickup-summary></player-pickup-summary>
  </div>
  <div style="grid-column: auto / span 2">
    <match-kills-chart></match-kills-chart>
  </div>
  <div style="grid-column: auto / span 2">
    <match-kdr-chart></match-kdr-chart>
  </div>
  <div style="grid-column: auto / span 2">
    <match-deaths-chart></match-deaths-chart>
  </div>
  <div style="grid-column: 1 / -1">
    <special-scores></special-scores>
  </div>

  <style>
    .duel-player {
      padding-top: 70px;
      height: 164px;
      width: 40%;
      text-align: center;
      text-shadow: 5px 1px 0px #0A9D91, -4px 1px 0px #93FFF6, 0px 5px 0px #0FDBCA, 0px -5px 0px #0FDBCA, 0px -5px 0px #008277;
      font-size: 52px;
      font-weight: bold;
    }
  </style>

{% endblock %}
