"""
Znake provides facilities for creating Python virtual environments.

A Python project built with Znake needs to provide a setup.py compatible with setuptools.
Requirements added to requirements.txt will be automatically installed using Pip.
Requirements added to requirements-dev.txt will be automatically installed using Pip but
will not be included when packaging the project.
"""
import datetime
import os
import urllib.parse
from textwrap import dedent

from invoke import Collection, call, task

from znake.util import render_template

from .docker import clean_venv_volume
from .setupgen import create_setup_py_file, remove_setup_py_file
from .util import run, skip_if_up_to_date


@task(default=True)
def create(ctx):
    """Create the local virtual Python environment."""
    pass


@task
def create_all(ctx):
    """Create all virtual Python environments."""
    pass


@task
def cleanup(ctx):
    """Remove all virtual Python environments."""
    remove_setup_py_file(ctx)
    remove_version_file(ctx)


@task
@skip_if_up_to_date('{package}/version.py')
def write_version_file(ctx):
    """Write the version.py file."""
    with open(os.path.join(ctx.znake.info.package, 'version.py'), 'w') as f:
        f.write(_render_write_version_file_command(ctx))


@task
@skip_if_up_to_date('setup.py')
def write_setup_py_file(ctx):
    """Write the setup.py file."""
    create_setup_py_file(ctx)


@task
@skip_if_up_to_date('{requirements_dir}/requirements.txt')
def write_requirements_file(ctx):
    """Write the znaketools/requirements.txt file."""
    ctx.run(_render_write_requirements_file_command(ctx))


@task
@skip_if_up_to_date('{requirements_dir}/requirements-dev.txt')
def write_requirements_dev_file(ctx):
    """Write the znaketools/requirements-dev.txt file."""
    ctx.run(_render_write_requirements_dev_file_command(ctx))


@task(
    pre=[
        write_version_file, write_requirements_file, write_requirements_dev_file,
        write_setup_py_file
    ])
@skip_if_up_to_date('.venv/bin/activate')
def create_venv(ctx, target):
    """Create a Python virtual environment."""

    if 'interpreter' in target:
        python = target['interpreter']
    else:
        python = '/usr/bin/python3'

    run(ctx, target['image'], '{python} -m venv .venv'.format(python=python), force_volume=True)
    _write_pip_config(ctx, target)

    run(ctx, target['image'], '.venv/bin/pip3 install --upgrade setuptools', use_venv=True)
    run(ctx, target['image'], '.venv/bin/pip3 install --upgrade pip', use_venv=True)
    run(
        ctx,
        target['image'],
        '.venv/bin/pip3 install -r {requirements_dir}/requirements.txt || true'.format(
            requirements_dir=ctx.build_dir.requirements_dir),
        use_venv=True)
    run(
        ctx,
        target['image'],
        '.venv/bin/pip3 install -r {requirements_dir}/requirements-dev.txt || true'.format(
            requirements_dir=ctx.build_dir.requirements_dir),
        use_venv=True)
    run(ctx, target['image'], '.venv/bin/pip3 install -e .', use_venv=True)


@task
def clean_venv(ctx, target):
    """Remove a Python virtual environment."""
    if target['image'] == 'local':
        run(ctx, target['image'], 'rm -rf .venv/*')
        run(ctx, target['image'], 'rm -rf *.egg-info')
        run(ctx, target['image'], 'rm -rf .eggs')
    else:
        clean_venv_volume(ctx, target['image'])


def generate_venv_tasks(target):
    if target['image'] == 'local':
        create.pre.append(call(create_venv, target=target))

    create_all.pre.append(call(create_venv, target=target))
    cleanup.pre.append(call(clean_venv, target=target))

    namespace = Collection(target['image'].replace('.', '-'))
    namespace.add_task(create_venv)
    namespace.add_task(clean_venv)
    return namespace


def _render_write_version_file_command(ctx):

    version = ctx.znake.info.changelog[0]['version']
    build_number = os.getenv('BUILD_NUMBER', 0)
    deb_package_name = ctx.znake.deb.package
    short_description = ctx.znake.info.short_description
    long_description = ctx.znake.info.long_description
    maintainer = ctx.znake.info.maintainer
    maintainer_email = ctx.znake.info.maintainer_email

    template_string = dedent(
        """\
        # This file is automatically generated by Znake
        from textwrap import dedent

        __version__ = '{{version}}-{{build_number}}'
        __updated__ = '{{updated}}'
        deb_package_name = '{{deb_package_name}}'
        description = '{{short_description}}'
        long_description = dedent('''\\\\
        {{long_description}}
            ''')
        maintainer = '{{maintainer}}'
        maintainer_email = '{{maintainer_email}}'

        changelog = [
            {%- for item in changelog %}
            {
                'version': '{{ item.version }}',
                'date': '{{ item.date }}',
                'changes': [
                    {%- for change in item.changes %}
                    '''{{ change }}''',
                    {%- endfor %}
                ],
            },
            {%- endfor %}
        ]

        """)

    return render_template(
        template_string,
        version=version,
        updated=datetime.datetime.now().strftime('%Y-%m-%d'),
        build_number=build_number,
        deb_package_name=deb_package_name,
        short_description=short_description,
        long_description='\n'.join(
            ['    {line}'.format(line=line) for line in long_description.strip().split('\n')]),
        maintainer=maintainer,
        maintainer_email=maintainer_email,
        changelog=ctx.znake.info.changelog)


def remove_version_file(ctx):
    """Remove the {package}/version.py file."""
    try:
        os.unlink(os.path.join(ctx.znake.info.package, 'version.py'))
    except FileNotFoundError:
        pass


def _render_write_pip_config_command(ctx):
    return (
        'cat <<EOF>.venv/pip.conf\n'
        '[global]\n'
        'index-url = {index_url}\n'
        'extra-index-url = https://pypi.org/simple\n'
        '\n'
        '[install]\n'
        'trusted-host = {trusted_host}\n'
        'EOF\n').format(
            index_url=ctx.znake.index_url,
            trusted_host=urllib.parse.urlparse(ctx.znake.index_url).netloc)


def _render_write_requirements_file_command(ctx):
    return (
        'mkdir -p {requirements_dir} && cat <<EOF>{requirements_dir}/requirements.txt\n'
        '--trusted-host {trusted_host}\n'
        '{requirements}\n'
        'EOF\n').format(
            trusted_host=urllib.parse.urlparse(ctx.znake.index_url).netloc,
            requirements_dir=ctx.build_dir.requirements_dir,
            requirements='\n'.join(ctx.znake.requirements))


def _render_write_requirements_dev_file_command(ctx):
    return (
        'mkdir -p {requirements_dir} && cat <<EOF>{requirements_dir}/requirements-dev.txt\n'
        '--trusted-host {trusted_host}\n'
        '{requirements}\n'
        'EOF\n').format(
            trusted_host=urllib.parse.urlparse(ctx.znake.index_url).netloc,
            requirements_dir=ctx.build_dir.requirements_dir,
            requirements='\n'.join(ctx.znake.requirements_dev))


def _write_pip_config(ctx, target):
    run(ctx, target['image'], _render_write_pip_config_command(ctx), force_volume=True)


def get_namespace(config):
    namespace = Collection('venv')
    for target in config.znake.test.targets:
        generate_venv_tasks(target)
    for target in config.znake.systest.targets:
        generate_venv_tasks(target)
    generate_venv_tasks({'image': 'quay.io/pypa/manylinux1_x86_64:latest'})

    namespace.add_task(create)
    namespace.add_task(cleanup)
    return namespace
